// Ctrl + Shift + кнопка стрелочки (any)      - выделение по словам в коде
// Ctrl + кнопка стрелочки (any)              - передвижение стрелочки по словам
// Ctrl + Shift + кнопка стрелочки вверх/вниз - выделение строку полностью от тек. позиции до такой же позиции ниже/выше или меньше
// Ctrl + кнопка точки/?                      - комментирует строку
// Ctrl + C         - загоняет в буфер, если ничего не выделено - копирует всю строку
// Ctrl + V         - вставляет в указанное место данные из буфера обмена
// Ctrl + S         - сохраняет текущие изменения в файле
// Ctrl + Z         - отменяет действие
// Ctrl + Shift + Z - отменяет отмену действия, т.е. возврат
// Ctrl + F         - поиск по файлу
// Ctrl + Shist + F - глобальный поиск по файлам
// Ctrl + A         - выделение всего
// Tab              - создает отступ от тек. позиции     
// Shift + Tab      - убирает отступы от тек. позиции            


//////////////////////////      М А С С И В Ы    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let arr = [];                                                     // обычное создание пустого массива
let arr = new Array;                                              // создание пустого массива с помощью встроенного конструктора Array
let arrNumber = [1, 13, 55, 23, -4, NaN, Infinity, -Infinity, 0]  // создание массива числовых значений, содерж-го 9 эл-тов

arrNumber[0]                          // получение 1-го эл-та массива. кот. равен 1
arrNumber.length                      // получение длины массива, равной 9
arrNumber[arrNumber.length - 1]       // получение последнего эл-та массива, равного 0
let numberOfItem = 2                  // создание числовой переменной numberOfItem со значением 2
arrNumber[numberOfItem]               // получение n-го эл-та массива, где номером n выступает переменная numberOfItem со значением 2, равного 55, что равносильно arrNumber[2]
let dataFromItem = arrNumber[0]                     // присвоение переменной dataFromItem значения 1-го эл-та массива. равного 1
let dataFromItem = arrNumber[numberOfItem]          // присвоение переменной dataFromItem значения n-го эл-та массива, где номером n выступает переменная numberOfItem со значением 2, равного 55, что равносильно arrNumber[2]
let dataFromItem = arrNumber[arrNumber.length - 1]  // присвоение переменной dataFromItem значения последнего эл-та массива, равного 0

let arrString = ['', '13', 'BLISS', ' $ ', 'null']
let arrBoolean = [false, true]
let arrSymbol = [Symbol(), Symbol('id'), Symbol(), Symbol('prop'), Symbol()]
let arrBigInt = [1n, 13n, 55n, 23n, -4n, 334455n]
let arrNull = [null, null, null]
let arrUndef = [undefined, undefined, undefined]
let arrObject = [{}, {name: "Ivan", age: 38}, {func() {}, isIt: false}]
let arrFunc = [function sum(...arr) {}, () => {}, function toString(str) {}]
let arrArray = [[], [1, 13, 55, 23, -4, NaN, Infinity, -Infinity, 0], ['', '13', 'BLISS', ' $ ', 'null'], [1n, 13n, 55n, 23n], [null, null, null]]
let arrDate = [new Date(), new Date('2021-12-12'), new Date(2021, 0, 1, 12, 30, 30)]
let arrFalse = [0, '', null, NaN, undefined, false]


//////////////////////////////     Ц И К Л Ы     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//while, do-while, for, for of , for in, forEach

let i = 0                                   // создается перем. i
while (i < arrFalse.length) {               // создается цикл WHILE с условием выхода, при кот. цикл будет  работать до тех пор, пока i не равняется длине массива arrFalse, равной 6
  console.log(' i = ', i, arrFalse[i])      // получение n-го эл-та массива, где в роли n выступает переменная i
  i++                                       // увеличиваем переменную i на 1 для следующей итерации (1 проход цикла)
}                                           // отработает 6 раз для arrFalse

let i = 0                                   // создается перем. i
do  {                                       // создается цикл DO-WHILE, который отработает минимум 1 раз, с условием выхода, при кот. цикл будет  работать до тех пор, пока i не равняется длине массива arrFalse, равной 6
  console.log(' i = ', i, arrFalse[i])      // получение n-го эл-та массива, где в роли n выступает переменная i
   i++                                      // увеличиваем переменную i на 1 для следующей итерации (1 проход цикла)
}                                           
while (i < arrFalse.length)                 // отработает 6 раз для arrFalse

for (let i = 0; i < arrFalse.length; i++) { // создается цикл FOR, кот. создает перем. итерации i, условие работы цикла и выражение изменения перем. итерации i (именно, увеличение на 1 после выполнения каждой итерации)
  console.log(' i = ', i, arrFalse[i])      // получение n-го эл-та массива, где в роли n выступает переменная i
}                                           // отработает 6 раз для arrFalse

for (let value of arrFalse) {               // создается цикл FOR-OF, кот. создает перем. value, которая является значением эл-та массива, т.е arrFalse[0], arrFalse[1], ...
  console.log(' value = ', value)           // получение следующего эл-та массива
}                                           // отработает 6 раз для arrFalse

for (let key in arrFalse) {                 // создается цикл FOR-IN, кот. создает перем. key, которая является ключом/индексом/порядковым номером эл-та массива; НЕ РЕКОМЕНДУЕТСЯ К ИСПОЛЬЗОВАНИЮ В МАССИВАХ (он - д/ОБ, у массива может захватить "нежелательные" ключи)
  console.log('key = ', key, arrFalse[key]) // получение n-го эл-та массива, где в роли n выступает переменная key
}                                           // отработает 6 раз для arrFalse

arrFalse.forEach((element, index, array) => {  // использование встроенного метода массива forEach, принимающего в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 3 парам. - 
  // 1 - эл-т тек. итериции element, 2 - индекс - порядковый номер index как эл-та массива, так и итерации, 3 - массив целиком, array; обычно хватает первого парам, иногда используется 2-й
  // не возвращает ничего, кроме undefined, не создает новый массив, не меняет тек. массив
 console.log(' el = ', element, index, array)  // получение следующего эл-та массива
})                                             // отработает 6 раз для arrFalse

// создать от arrFalse map, sort, filter, indexOf, findIndex, find, reduce
arrFalse.map((element, index, array) => { // создает новый массив на основании arrFalse и меняет каждый эл-т массива в зав-ти от данных, которые мы возвращаем с помощью return;
  // map принимает в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 3 парам. - 
  // 1 - эл-т тек. итериции element, 2 - индекс - порядковый номер index как эл-та массива, так и итерации, 3 - массив целиком, array; обычно хватает первого парам;
  // возвращает видоизмененную копию оригинала (исходного массива), не меняет сам оригинал (тек. массив)
  return !!element                        // происходит замена эл-та на тек. итерации, в данной ситуации "!!" преобразовает в булево (аналог Boolean(element))
})                                        // отработает 6 раз для arrFalse

arrFalse.sort((a, b) => {                 // создает новый массив на основании текущего и оба сортирует; 
  // sort имеет стандартный функ-л, который сортирует по первым символам элемента (как строки);
  // принимает в кач-ве аргумента ф-цию, имеющую 2 парам, обозначающих эл-ты; требует возвращения числа, кот. определяет направление перестановки эл-та
  return a - b
})
  // & [11,2,22,1].sort((a, b) => a - b) - сортирует нормально, как числа

arrFalse.filter((element, index, array) => { // создает новый массив на основании текущего и фильтрует его в зависимости от данных, которые мы возвращаем с помощью return;
  // filter принимает в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 3 парам. - 
  // 1 - эл-т тек. итериции element, 2 - индекс - порядковый номер index как эл-та массива, так и итерации, 3 - массив целиком, array; обычно хватает первого парам, иногда фильтрует по индексу;
  // return возвращает булевое значение, н-р, return el > 5
  return element > 5  // условие возвращает булево для каждого эл-та массива
})

arrFalse.indexOf(searchElement, fromIndex) // находит знач. searchElement в массиве (доп. аргумент fromIndex определяет нач. позицию поиска)
  // возвращает пор. номер найденного эл-та или -1

arrFalse.findIndex((element, index, array) => { // возвращает индекс (пор. номер) первого эл-та, удовлетворяющего заданному условию
  // findIndex принимает в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 3 парам. - 
  // 1 - эл-т тек. итериции element, 2 - индекс - порядковый номер index как эл-та массива, так и итерации, 3 - массив целиком, array; обычно хватает первого парам;
  return element === 0 // условие будет выполняться д/каждого эл-та массива (в данном массиве вернет индекс 1-го эл-та, т.е. 0)
})
arrFalse.find((element, index, array) => {// возвращает первый эл-т, удовлетворяющего заданному условию
  // find принимает в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 3 парам. - 
  // 1 - эл-т тек. итериции element, 2 - индекс - порядковый номер index как эл-та массива, так и итерации, 3 - массив целиком, array; обычно хватает первого парам;
  return element === 0 // условие будет выполняться д/каждого эл-та массива (в данном массиве вернет 1-й эл-т)
})})

arrFalse.reduce((previousValue, currentValue, currentIndex, array) => { // возвращает одно значение, которое собирается при прохождении по массиву;
  // reduce принимает в кач-ве арг-та ф-цию (в основном стрелочную), которая принимает 4 парам. - 
  // 1 - эл-т преё дыдущей итерации, это значение 2-го арг-та reduce (в данном случае - initialValue), если он задан или значение первого эл-та массива; 
  // далее принимает значение результата пред. итерации;
  // 2 - эл-т тек. итерации (тек. эл-т массива); 3 - индекс тек. эл-та массива; 4 - массив целиком, array; обычно хватает первых 2-х парам;
  return previousValue + currentValue // в данном случа суммирует значения пред. и тек. эл-тов массива; 
  // return вернет результат в значение previousValue для след. итерации
}, initialValue) // initialValue - необязат. парам.


/////////////////  З А Д А Ч И  \\\\\\\\\\\\\\\\\\\\\\
// создать ф-цию, принимающую 1 парам - массив arrayOfNumbers и возвр. ОБ с 7 св-вами : min, max, sum, length, amountOfNegative, 
// amountOfPositive и hasZero, 
// а также методы: reverse (возвр. перевернутый массив), toNegative (меняет знач. массива на противоположные), filterForMe (принимает
// ф-цию в кач-ве арг-та, кот. возвр. булево, и возвр. отфильтрованный массив), toNormal (возвр. массиву исх. значение)

////////////     АЛГОРИТМ решения любой задачи   \\\\\\\\\\\\\\\\\\\
// 1) прочтение условия задачи и выявление какой д.б. рез-т, что нужно получить, а именно как выглядят данные, что пришло,
// какие инструменты есть в нашем распоряжении, как будет выглядеть рез-т, какие действия нужно совершить и т.д.;
// 2) разабивка задачи на подзадачи, пункты, н-р, 
    // 1. описать ф-цию в общем виде; 
    // 2. добавить парам-ры; 
    // 3. описать рез-т в общем виде;
    // 4. добавить функционал такой-то ...
// 3) проверка/отладка алгоритмов на все примеры, которые влезут в голову;
// 4) попытаться поломать функционал
// 5) попробовать найти возможность оптимизировать функционал
// 6) сравнение полученного рез-та с требуемым по условию задачи
// 7) тестировка
// 8) сдача

// создать ф-цию, принимающую 1 парам - массив arrayOfNumbers и возвр. ОБ с 7 св-вами : min, max, sum, length, amountOfNegative, 
// amountOfPositive и hasZero, 
// а также методы: reverse (возвр. перевернутый массив), toNegative (меняет знач. массива на противоположные), filterForMe (принимает
// ф-цию в кач-ве арг-та, кот. возвр. булево, и возвр. отфильтрованный массив), toNormal (возвр. массиву исх. значение)

//    Решение - разбивка на подзадачи
// 1. описать ф-цию в общем виде, с парам arrayOfNumbers
// 2. описать возврат результата, а именно ОБ с 7 св-вами (min, max, sum, length, amountOfNegative, amountOfPositive и hasZero, ) и 4 методами (reverse, toNegative, filterForMe, toNormal)
// 3.  найти мин. знач. в массиве  (min: number)
// 4.  найти макс. знач. в массиве (max: number)
// 5.  найти сумму значений эл-тов массива (sum: number)
// 6.  найти длину массива (length: number)
// 7.  найти к-во отрицат. значений (amountOfNegative: number)
// 8.  найти к-во положит. значений (amountOfPositive: number)
// 9.  проверить наличие 0 (hasZero: boolean)
// 10. сохранить в this исходное значение массива для метода toNormal - новое св-во obj.arrayOfNumbers = arrayOfNumbers;
// 11. метод reverse - написать ф-цию без исп-я Array.reverse(), кот. вернет массив в обратном порядке, т.е. forEach создать новый массив с конца исх. до его начала
// 12. метод toNegative - написать ф-цию, кот. возвращает массив значений с противоположными знаками  - map, умножить на -1
// 13. метод filterForMe - написать ф-цию, кот. принимает в парам ф-цию под именем filterFunction и с помощью метода массива filter, 
// внутри которого будет возвращаться рез-т вызова filterFunction (в которую (filterFunction) будет передаваться эл-т в кач-ве парам) 
// и возвращает отфильтрованный массив 
// function filterForMe(filterFunction) {return arrayOfNumbers.filter((el) => {return filterFunction(el)})}
// 14. метод toNormal - возвращает исх. массив arrayOfNumbers из this
// 15. заменить вызовы методов из массива arrayOfNumbers на массив this.arrayOfNumbers - ?????????????????
// 16. проверить работу с массивами:
//    [2, 6, 9, 25, -6]
//    [2, 0, 2222, 2, 7]
//    [0, -22, 69999, 0, -1
//    [3/5, -0.000000001, 232323n, 5n, 09n, Math.PI]
//    [25e2, Math.E, Infinity, NaN, 0n]
// 17. попробовать запустить ф-цию с другим типом данных
// 18. оптимизировать функционал
// 19. сохранить изменения в git, закоммитить и запУшить в ветку на github


function createObject(arrayOfNumbers) {
  return {
    arrayOfNumbers: [...arrayOfNumbers],
    min: Math.min(...arrayOfNumbers),
    max: Math.max(...arrayOfNumbers),
    maxSort: [...arrayOfNumbers].sort((acc, next) => (next - acc))[0],  
    sum: arrayOfNumbers.reduce((acc, next) => (acc + next)),
    length: arrayOfNumbers.length,
    amountOfNegative: arrayOfNumbers.filter((el) => el < 0).length,
    amountOfPositive: arrayOfNumbers.filter((el) => el > 0).length,
    hasZero: arrayOfNumbers.indexOf(0) > -1,
    reverseUnshift() {
      let newArray = [];
      this.arrayOfNumbers.forEach((element) => newArray.unshift(element)) 
      return newArray;
    },
    reverseString() {
      this.arrayOfNumbers
        .split('')
        .reverse()
        .join('');
    },
    reverse() {
      let newArray = [];
      for (i = arrayOfNumbers.length - 1; i >= 0; i--) {
        newArray.push(arrayOfNumbers[i]); 
      }  
      return newArray;
    },
    toNegative() {
      return this.arrayOfNumbers.map((el) => -1 * el ) 
    },
    filterForMe(filterFunction) { 
      // return arrayOfNumbers.filter((el) => filterFunction(el)) 
      // более сокращенная запись
      return arrayOfNumbers.filter(filterFunction) 
    },
    toNormal() {
      return this.arrayOfNumbers
    },
  }
}
